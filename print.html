<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZeroMQ Guide</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/socket.html"><strong aria-hidden="true">1.1.</strong> Socket</a></li><li class="chapter-item expanded "><a href="basics/methods.html"><strong aria-hidden="true">1.2.</strong> Methods</a></li><li class="chapter-item expanded "><a href="basics/patterns.html"><strong aria-hidden="true">1.3.</strong> Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">2.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/protocols.html"><strong aria-hidden="true">2.1.</strong> Custom Protocols</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/basic_req_rep.html"><strong aria-hidden="true">3.1.</strong> Basic Request Reply</a></li><li class="chapter-item expanded "><a href="examples/reliable_req_rep.html"><strong aria-hidden="true">3.2.</strong> Reliable Request Reply</a></li><li class="chapter-item expanded "><a href="examples/secure_req_rep.html"><strong aria-hidden="true">3.3.</strong> Secure Request Reply</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">ZeroMQ Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about" id="about">About</a></h1>
<h2><a class="header" href="#this-is-a-wip-guide" id="this-is-a-wip-guide">This is a WIP guide</a></h2>
<p>I believe that <code>ZeroMQ</code> is a diamond in the rough that is still a in the early
adoption stage despite being a mature project. In my opinon, the lack of traction
for the library is due to the community rather than the technology itself.</p>
<p><code>ZeroMQ</code> suffers from a significant learning curve due to its foreign concepts.
It requires the programmer to think differently about messaging. When this is
combined with a lacking documentation, it results in very significant time
requirement to properly understand how the library works and how it can be used.</p>
<p>I want this guide to reduce this time requirement by explaining the key concepts of
<code>ZeroMQ</code>, give real world usage examples as well as a general vision of how it
could be use. To do so, we will use <a href="https://github.com/jean-airoldie/libzmq-rs">libzmq-rs</a> which is a library aimed at
making <code>ZeroMQ</code> dead simple to use.</p>
<h2><a class="header" href="#reading-tips" id="reading-tips">Reading Tips</a></h2>
<ul>
<li>There is a search-bar friendly glossary at the end of the guide.</li>
</ul>
<h1><a class="header" href="#basics" id="basics">Basics</a></h1>
<p>This is the minimal set of concepts required to get a decent grasp of <code>libzmq</code>.</p>
<h1><a class="header" href="#socket" id="socket">Socket</a></h1>
<p>The concept of a <code>socket</code> in <code>ZeroMQ</code> is completely novel. A <code>ZeroMQ</code> socket
differs from a traditional <code>TCP</code> socket in the following ways (but not limited to):</p>
<ul>
<li>A socket sends and receives atomic messages; messages are guaranteed to
either be transmitted in their entirety, or not transmitted at all.</li>
<li>A socket send and receive messages asynchronously.</li>
<li>A socket can transmit messages over many supported transports, including <code>TCP</code>.</li>
<li>Incoming and outgoing messages can be queued and transmitted asynchronously
by a background I/O thread.</li>
<li>A socket can be connected to zero or more peers at any time.</li>
<li>A socket can be bound to zero or more endpoints at any time. Each bound
endpoint can listen to zero or more peers.</li>
<li>Peer reconnection and disconnection is handled in the background.</li>
<li>Support for many authentication and encryption strategies via <a href="https://docs.rs/libzmq/0.1/libzmq/auth/enum.Mechanism.html">Mechanism</a>.</li>
</ul>
<h1><a class="header" href="#basics-1" id="basics-1">Basics</a></h1>
<p>These are the basic methods required to use a socket.</p>
<h2><a class="header" href="#connect" id="connect">Connect</a></h2>
<p>The socket <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.Socket.html#method.connect">connect</a> method is use to connect to a peer socket bound
at an endpoint to communicate with a peer. Usually a client socket will connect
to a server socket, but it could be the other way around.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let addr: TcpAddr = &quot;8.8.8.8:420&quot;.try_into()?;
client.connect(addr)?;
<span class="boring">}
</span></code></pre></pre>
<p>Calling <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.Socket.html#method.connect">connect</a> on a socket is not guaranteed to connect to the peer right
away. Usually, the actual connect call will be delayed until it is needed
(e.g. when sending a message).</p>
<p>Connections in <code>ZeroMQ</code> are different from traditional connections is the
sense that they automatically handle failure. For instance, if a connection
fails because of a network error, it will be automatically reconnected if
possible.</p>
<p>Furthermore, to successfully connect to a peer, the handshake corresponding to
the mechanism used must succeed. This handshake is also done in the background
and might fail for various reasons.</p>
<h2><a class="header" href="#bind" id="bind">Bind</a></h2>
<p>The socket <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.Socket.html#method.bind">bind</a> method is used to bind a local endpoint to accept connections
from peers. Usually a server socket will bind a known endpoint so that other socket
can connect to it.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let addr: TcpAddr = &quot;127.0.0.1:*&quot;.try_into()?;
server.bind(addr)?;
<span class="boring">}
</span></code></pre></pre>
<p>Contrairy to <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.Socket.html#method.connect">connect</a>, <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.Socket.html#method.bind">bind</a> will attempt to bind to the endpoint straight
away. If the bind call succeeds, the socket will start to accept connections
attempts to this endpoint.</p>
<h2><a class="header" href="#send" id="send">Send</a></h2>
<p>This a fundamental operation of a socket used to transfert messages to another
socket. To be able to send messages, a socket must implement the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.SendMsg.html">SendMsg</a> trait.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>client.send(msg)?;
<span class="boring">}
</span></code></pre></pre>
<p>When <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.SendMsg.html#method.send">send</a> is called on a socket, it will attempt to queue the message
to its outgoing buffer. If the buffer is full, meaning it has reached the
high water mark, the operation will block. If the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.SendMsg.html#method.send_timeout">send_timeout</a> is set
to <code>Period::Infinite</code>, the operation will block until the buffer can accomodate for
the message. Otherwise if the timeout is set to <code>Period::Finite(Duration)</code>, it
will attempt to queue the message for that duration and if it fails,
return [WouldBlock].</p>
<p>There is also the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.SendMsg.html#method.try_send">try_send</a> method which will return with [WouldBlock] immediately
if it cannot queue the message.</p>
<p>Queued messages are send by a background I/O thread to the peer socket.
For the messages to be actually sent two conditions must be met:</p>
<ul>
<li>The connection with the peer socket is up.</li>
<li>The peer socket can receive messages (its incoming buffer is not full).</li>
</ul>
<p>Conceptually, a full outgoing buffer can mean many things:</p>
<ul>
<li>The connection has crashed temporarily (network error etc.)</li>
<li>The peer socket has crashed and is restarting.</li>
<li>The peer socket receives message slower than we can send
them (thus this is a back throttling mechanism)</li>
<li>Etc.</li>
</ul>
<p>Many of these scenarios are conceptually indistinguishable. Therefore
the user has to decide what to do depending on the context.</p>
<h2><a class="header" href="#recv" id="recv">Recv</a></h2>
<p>You guessed it, <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.RecvMsg.html#method.recv">recv</a> is a socket operation used to receive messages from
another socket. To be able to receive messages, a socket must implement
the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.RecvMsg.html">RecvMsg</a> trait.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let msg = client.recv_msg()?;
<span class="boring">}
</span></code></pre></pre>
<p>Calling <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.RecvMsg.html#method.recv">recv</a> on a socket will attempt to extract a message from its
incoming buffer. If the incoming buffer is empty, the operation will
block until a mesage is received in the buffer. If the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.RecvMsg.html#method.recv_timeout">recv_timeout</a>
is specified, it will try to extract a message from the buffer for the
given duration and return [WouldBlock] if it failed.</p>
<p>There is also the <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.RecvMsg.html#method.try_recv">try_recv</a> method which, similarly to <a href="https://docs.rs/libzmq/0.1/libzmq/prelude/trait.SendMsg.html#method.try_send">try_send</a>, will return
with [WouldBlock] immediately if it cannot queue the message.</p>
<p>The incoming buffer receives message from the background I/O thread from the
peer socket. For the messages to be actually received two conditions must be met:</p>
<ul>
<li>The connection with the peer socket is up.</li>
<li>The incoming buffer is not full.</li>
</ul>
<p>Conceptually, an empty incoming buffer can mean many things:</p>
<ul>
<li>The socket can receive messages faster than what the peer can send.</li>
<li>The peer has no messages to send.</li>
<li>The connection has a network error.</li>
<li>The peer has crashed</li>
<li>Etc.</li>
</ul>
<p>Like before, many of these scenarios are conceptually indistinguishable.
We have to decide what to do depending on the context.</p>
<h1><a class="header" href="#patterns" id="patterns">Patterns</a></h1>
<p>These are the most basic socket patterns in <code>libzmq</code>.</p>
<h2><a class="header" href="#client-server" id="client-server">Client-Server</a></h2>
<p>The <code>Client-Server</code> pattern is a advanced asynchronous request-reply pattern.</p>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Server.html">Server</a> receives messages with a unique <a href="https://docs.rs/libzmq/0.1/libzmq/struct.RoutingId.html">RoutingId</a> associated with a
<a href="https://docs.rs/libzmq/0.1/libzmq/struct.Client.html">Client</a>. This <a href="https://docs.rs/libzmq/0.1/libzmq/struct.RoutingId.html">RoutingId</a> can be used by the <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Server.html">Server</a> to route replies to the
<a href="https://docs.rs/libzmq/0.1/libzmq/struct.Client.html">Client</a>.</p>
<pre><code>       &lt;───&gt; client
server &lt;───&gt; client
       &lt;───&gt; client

</code></pre>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Client.html">Client</a> socket receives upstream messages in a fair-queued fashion</p>
<pre><code>server ─┐
server ────&gt; client
server ─┘
</code></pre>
<h2><a class="header" href="#radio-dish" id="radio-dish">Radio-Dish</a></h2>
<p>The <code>Radio-Dish</code> pattern is an asynchronous publish-subscribe pattern.</p>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Radio.html">Radio</a> socket send messages in a fan-out fashion to all <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Dish.html">Dish</a>
that <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Dish.html#method.join">joined</a> the message's <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Group.html">Group</a>.</p>
<pre><code>      ────&gt; dish
radio ────&gt; dish
      ────&gt; dish
</code></pre>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Dish.html">Dish</a> socket receive messages from <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Group.html">Group</a> it has <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Dish.html#method.join">joined</a> in a
fair-queued fashion.</p>
<pre><code>radio ─┐
radio ────&gt; dish
radio ─┘
</code></pre>
<h2><a class="header" href="#scatter-gather" id="scatter-gather">Scatter-Gather</a></h2>
<p>The <code>Scatter-Gather</code> pattern is an asynchronous pipeline pattern.</p>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Scatter.html">Scatter</a> socket send messages downstream in a round-robin fashion</p>
<pre><code>         ┌──&gt; gather
scatter ────&gt; gather
         └──&gt; gather
</code></pre>
<p>The <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Gather.html">Gather</a> socket receives upstream messages in a fair-queued fashion</p>
<pre><code>scatter ─┐
scatter ───&gt; gather
scatter ─┘
</code></pre>
<h1><a class="header" href="#advanced" id="advanced">Advanced</a></h1>
<p>Now that the basic stuff is taken care off, lets dig deeper.</p>
<h1><a class="header" href="#custom-protocols" id="custom-protocols">Custom Protocols</a></h1>
<p>For two peers to be able to communicate, they must share a contract. In the
world of communication, these are called protocols. <code>ZeroMQ</code> enables
programmer to create protocols that suit their needs by removing most of the
boilerplate.</p>
<p>You might have realized by now that there is no strict concept of request-reply
as a socket operation. Indeed the library does not enforce a client socket
to follow a <code>send</code> call by a <code>recv</code> call. This does't mean however that this
strict type of request-reply could not be achieved. To do so, a programmer could
easily write the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Client side
fn request_reply(&amp;mut self, msg: Msg) -&gt; Result&lt;Msg, Error&gt; {
    self.client.send(msg)?;
    self.client.recv_msg()?
}

// Server side
fn run(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
    loop {
        let request = self.server.recv_msg()?;
        let reply = self.on_request(request)?;
        self.server.send(reply)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This creates an implicit contract between the client and the server.
We will disregard the error handling and timeouts for simplicity.</p>
<ul>
<li>The client must send one request at a time and wait for one reply.</li>
<li>The server must wait for a request and send one reply.</li>
</ul>
<p>Since contract must be ensured at the application level, it must be properly
documentated for developpers to be able to respect it.</p>
<p><code>ZeroMQ</code> does not enforce a particular messaging protocol, instead
it offers all the tools to build one.</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>Here are a few examples usage of varying complexity.</p>
<h1><a class="header" href="#basic-request-reply" id="basic-request-reply">Basic Request Reply</a></h1>
<p>This is as simple as it gets. We have a <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Server.html">Server</a> that does some request-reply
work in a dedicated thread. We have a <a href="https://docs.rs/libzmq/0.1/libzmq/struct.Client.html">Client</a> that sends a &quot;ping&quot; and gets
a &quot;pong&quot; back. There is no attempt at security and no attempt at error handling.
For a <code>INPROC</code> server, that might be enough.</p>
<pre><pre class="playpen"><code class="language-rust">use libzmq::{prelude::*, *};

use std::thread;

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let addr: InprocAddr = InprocAddr::new_unique();

    let server = ServerBuilder::new().bind(&amp;addr).build()?;

    // Spawn the server thread.
    let handle = thread::spawn(move || -&gt; Result&lt;(), Error&gt; {
        loop {
            let request = server.recv_msg()?;
            assert_eq!(request.to_str(), Ok(&quot;ping&quot;));

            // Retrieve the routing_id to route the reply to the client.
            let id = request.routing_id().unwrap();
            // We cast the Error&lt;Msg&gt; to Error&lt;()&gt;. This drops the Msg.
            server.route(&quot;pong&quot;, id).map_err(Error::cast)?;
        }
    });

    let client = ClientBuilder::new().connect(addr).build()?;

    // Do some request-reply work.
    client.send(&quot;ping&quot;)?;
    let msg = client.recv_msg()?;
    assert_eq!(msg.to_str(), Ok(&quot;pong&quot;));

    // This will cause the server to fail with `InvalidCtx`.
    Ctx::global().shutdown();

    // Join with the thread.
    let err = handle.join().unwrap().unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidCtx);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::main;

    #[test]
    fn main_runs() {
        main().unwrap();
    }
}

</code></pre></pre>
<h1><a class="header" href="#reliable-request-reply" id="reliable-request-reply">Reliable Request Reply</a></h1>
<p>This is a basic example when using the <code>TCP</code> transport adapting the code
from the previous <code>Basic Request Reply</code> example.</p>
<p>Note that this example does not make any attempt at security.</p>
<p>Since <code>TCP</code> is connection oriented transport, we have to take in account that
the connection might fail at any time. We use heartbeating to detect failure
but also <code>send</code> and <code>recv</code> timeouts to prevent blocking forever.</p>
<p>In this example, the server is protected against failures since it will drop
messages if it is unable to route them before <code>send_timeout</code> expires (<code>WouldBlock</code>),
or it detects that the peer disconnected via the heartbeats (<code>HostUnreachable</code>).</p>
<p>The client in this case will simply fail if it unable to send a request before the
<code>send_timeout</code> or unable to receive a reply before the <code>recv_timeout</code> (<code>WouldBlock</code>).
The client might choose to retry later or connect to another server etc.</p>
<pre><pre class="playpen"><code class="language-rust">use libzmq::{prelude::*, *};

use std::{thread, time::Duration};

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    // We use a system assigned port here.
    let addr: TcpAddr = &quot;127.0.0.1:*&quot;.try_into()?;
    let duration = Duration::from_millis(300);

    let hb = Heartbeat::new(duration)
        .add_timeout(3 * duration)
        .add_ttl(3 * duration);

    let server = ServerBuilder::new()
        .bind(addr)
        .send_timeout(duration)
        .heartbeat(&amp;hb)
        .build()?;

    // Retrieve the assigned port.
    let bound = server.last_endpoint()?;

    // Spawn the server thread. In a real application, this
    // would be on another node.
    let handle = thread::spawn(move || -&gt; Result&lt;(), Error&gt; {
        use ErrorKind::*;
        loop {
            let request = server.recv_msg()?;
            assert_eq!(request.to_str(), Ok(&quot;ping&quot;));

            // Retrieve the routing_id to route the reply to the client.
            let id = request.routing_id().unwrap();
            if let Err(err) = server.route(&quot;pong&quot;, id) {
                match err.kind() {
                    // Cannot route msg, drop it.
                    WouldBlock | HostUnreachable =&gt; (),
                    _ =&gt; return Err(err.cast()),
                }
            }
        }
    });

    let client = ClientBuilder::new()
        .connect(bound)
        .recv_timeout(duration)
        .send_timeout(duration)
        .heartbeat(hb)
        .build()?;

    // Do some request-reply work.
    client.send(&quot;ping&quot;)?;
    let msg = client.recv_msg()?;
    assert_eq!(msg.to_str(), Ok(&quot;pong&quot;));

    // This will cause the server to fail with `InvalidCtx`.
    Ctx::global().shutdown();

    // Join with the thread.
    let err = handle.join().unwrap().unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidCtx);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::main;

    #[test]
    fn main_runs() {
        main().unwrap();
    }
}

</code></pre></pre>
<h1><a class="header" href="#secure-request-reply" id="secure-request-reply">Secure Request Reply</a></h1>
<p>The previous example did not offer neither authentication nor encryption.
For a public <code>TCP</code> connection, its a must. Let's fix that by adapting the
previous example.</p>
<p>This time we will the <code>CURVE</code> mechanism, which is a public-key crypto.
To enable the usage of the <code>CURVE</code> mechanism, the feature flag 'curve'
must be enabled.</p>
<p>However, this time we will use an external configuration file to get
rid of all the boilerplate. This will also allows our application
to run indepently of the socket configuration.</p>
<p>Based on some basic benchmarks, the <code>CURVE</code> mechanism
might reduce the throughtput of I/O heavy applications by half due
to the overhead of the <code>salsa20</code> encryption.</p>
<h2><a class="header" href="#config-file" id="config-file">Config File</a></h2>
<p>In this case we used <code>yaml</code> configuration file, but any file format
supported by <code>Serde</code> will work (as long as it supports typed enums).</p>
<pre><code class="language-yml"># The curve keys where generated by running:
# `$ cargo run --example gen_curve_cert`

auth:
  # The public keys allowed to authenticate. Note that this is
  # the client's public key.
  curve_registry:
    - &quot;n%3)5@(3pzp)v8yt6RW3eQVq5OQYb#TEodD^6oA^&quot;

client:
  # In a real life scenario the server would have a known addr.
  #connect:
  #  - tcp: &quot;127.0.0.1:3000&quot;
  heartbeat:
      interval: 1s
      timeout: 3s
      ttl: 3s
  send_high_water_mark: 10
  send_timeout: 300ms
  recv_high_water_mark: 100
  recv_timeout: 300ms
  mechanism:
    curve_client:
      client:
        public: &quot;n%3)5@(3pzp)v8yt6RW3eQVq5OQYb#TEodD^6oA^&quot;
        secret: &quot;JiUDa&gt;&gt;owH1+mPTWs=&gt;Jcyt%h.C1E4Js&gt;)(g{geY&quot;
      # This is the server's public key.
      server: &quot;et189NB9uJC7?J+XU8JRhCbF?gOP9+o%kli=y2b8&quot;

server:
  # Here we use a system defined port so as to not conflict with the host
  # machine. In a real life scenario we would have a port available.
  bind:
    - tcp: &quot;127.0.0.1:*&quot;
  heartbeat:
      interval: 1s
      timeout: 3s
      ttl: 3s
  mechanism:
    curve_server:
      secret: &quot;iaoRiIVA^VgV:f4a&lt;@{8K{cP62cE:dh=4:oY+^l(&quot;

</code></pre>
<h2><a class="header" href="#the-code" id="the-code">The code</a></h2>
<p>Aside from the additionnal logic for reading the config file,
the code is now simpler than before.</p>
<pre><pre class="playpen"><code class="language-rust">use libzmq::{config::*, prelude::*, *};

use serde::{Deserialize, Serialize};

use std::{
    fs::File,
    io::Read,
    path::{Path, PathBuf},
    thread,
};

const CONFIG_FILE: &amp;str = &quot;secure_req_rep.yml&quot;;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    auth: AuthConfig,
    client: ClientConfig,
    server: ServerConfig,
}

fn read_file(name: &amp;Path) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(name)?;
    let mut buf = Vec::new();
    file.read_to_end(&amp;mut buf)?;
    Ok(buf)
}

fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let path = PathBuf::from(&quot;examples&quot;).join(CONFIG_FILE);

    let config: Config =
        serde_yaml::from_slice(&amp;read_file(&amp;path).unwrap()).unwrap();

    // Configure the `AuthServer`. We won't need the returned `AuthClient`.
    let _ = config.auth.build()?;

    // Configure our two sockets.
    let server = config.server.build()?;
    let client = config.client.build()?;

    // Once again we used a system assigned port for our server.
    let bound = server.last_endpoint()?;
    client.connect(bound)?;

    // Spawn the server thread. In a real application, this
    // would be on another node.
    let handle = thread::spawn(move || -&gt; Result&lt;(), Error&gt; {
        use ErrorKind::*;
        loop {
            let request = server.recv_msg()?;
            assert_eq!(request.to_str(), Ok(&quot;ping&quot;));

            // Retrieve the routing_id to route the reply to the client.
            let id = request.routing_id().unwrap();
            if let Err(err) = server.route(&quot;pong&quot;, id) {
                match err.kind() {
                    // Cannot route msg, drop it.
                    WouldBlock | HostUnreachable =&gt; (),
                    _ =&gt; return Err(err.cast()),
                }
            }
        }
    });

    // Do some request-reply work.
    client.send(&quot;ping&quot;)?;
    let msg = client.recv_msg()?;
    assert_eq!(msg.to_str(), Ok(&quot;pong&quot;));

    // This will cause the server to fail with `InvalidCtx`.
    Ctx::global().shutdown();

    // Join with the thread.
    let err = handle.join().unwrap().unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidCtx);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::main;

    #[test]
    fn main_runs() {
        main().unwrap();
    }
}

</code></pre></pre>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>Some high level definitions.</p>
<h2><a class="header" href="#endpoint" id="endpoint">Endpoint</a></h2>
<p>A endpoint is a rendez-vous address for a specified transport. The syntax
of the address depends on the nature of the transport. For instance
a <code>TcpAddr</code> is an endpoint over the <code>TCP</code> transport.</p>
<h2><a class="header" href="#transport" id="transport">Transport</a></h2>
<p>A protocol to transfert data. Could be a network protocol, such as <code>TCP</code>,
could be a inter-thread protocol, such as <code>INPROC</code>, etc.</p>
<h2><a class="header" href="#connection" id="connection">Connection</a></h2>
<p>Connections in <code>ZeroMQ</code> are different from traditional connections is the
sense that they automatically handle failure. For instance, if a connection
fails because of a network error, it will be automatically reconnected if
possible. Thus sockets should not worry about the state of a given connection.</p>
<h2><a class="header" href="#message" id="message">Message</a></h2>
<p>An atomic arbitrary set of bytes owned by the <code>ZeroMQ</code> engine. <code>ZeroMQ</code> does
not know how to interpret these bytes, only the user does. Messages are
the units that are transferred between sockets.</p>
<h2><a class="header" href="#socket-1" id="socket-1">Socket</a></h2>
<p>A <code>ZeroMQ</code> construct used to send and receive messages using connections
accros endpoints. The specific behavior of the socket depends on its type.</p>
<h2><a class="header" href="#high-water-mark" id="high-water-mark">High Water Mark</a></h2>
<p>The message limit in the incoming or outgoing buffer. If the incoming
buffer has reached this limit, the socket will stop receiving messages
in the background. If the outgoing buffer has reached this limit, attempting
to queue a message will block the calling thread. Conceptually, this is a
socket's back throttling mechanism.</p>
<h2><a class="header" href="#context" id="context">Context</a></h2>
<p>A <code>ZeroMQ</code> context is a session that keeps track of all the sockets,
the messages, the async threads and the internal queries.</p>
<h2><a class="header" href="#mechanism" id="mechanism">Mechanism</a></h2>
<p>A specific protocol used by sockets to authenticate and encrypt traffic.</p>
<h2><a class="header" href="#mute-state" id="mute-state">Mute State</a></h2>
<p>A socket that is in mute state is unable to queue and receive messages.
This is likely because it has no peers. The condition for the mute state to
occur depends on the socket type.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
